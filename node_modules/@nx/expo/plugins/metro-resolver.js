"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResolveRequest = getResolveRequest;
const metroResolver = require("metro-resolver");
const tsconfig_paths_1 = require("tsconfig-paths");
const pc = require("picocolors");
const enhanced_resolve_1 = require("enhanced-resolve");
const path_1 = require("path");
const fs = require("fs");
const devkit_1 = require("@nx/devkit");
/*
 * Use tsconfig to resolve additional workspace libs.
 *
 * This resolve function requires projectRoot to be set to
 * workspace root in order modules and assets to be registered and watched.
 */
function getResolveRequest(extensions, exportsConditionNames = [], mainFields = []) {
    return function (_context, realModuleName, platform) {
        const debug = process.env.NX_REACT_NATIVE_DEBUG === 'true';
        const { resolveRequest, ...context } = _context;
        const resolvedPath = resolveRequestFromContext(resolveRequest, _context, realModuleName, platform, debug) ??
            defaultMetroResolver(context, realModuleName, platform, debug) ??
            tsconfigPathsResolver(context, extensions, realModuleName, platform, debug) ??
            pnpmResolver(extensions, context, realModuleName, debug, exportsConditionNames, mainFields);
        if (resolvedPath) {
            return resolvedPath;
        }
        if (debug) {
            console.log(pc.red(`[Nx] Unable to resolve with any resolver: ${realModuleName}`));
        }
        throw new Error(`Cannot resolve ${pc.bold(realModuleName)}`);
    };
}
function resolveRequestFromContext(resolveRequest, context, realModuleName, platform, debug) {
    try {
        return resolveRequest(context, realModuleName, platform);
    }
    catch {
        if (debug)
            console.log(pc.cyan(`[Nx] Unable to resolve with default resolveRequest: ${realModuleName}`));
    }
}
/**
 * This function try to resolve path using metro's default resolver
 * @returns path if resolved, else undefined
 */
function defaultMetroResolver(context, realModuleName, platform, debug) {
    try {
        return metroResolver.resolve(context, realModuleName, platform);
    }
    catch {
        if (debug)
            console.log(pc.cyan(`[Nx] Unable to resolve with default Metro resolver: ${realModuleName}`));
    }
}
/**
 * This resolver try to resolve module for pnpm.
 * @returns path if resolved, else undefined
 * This pnpm resolver is inspired from https://github.com/vjpr/pnpm-react-native-example/blob/main/packages/pnpm-expo-helper/util/make-resolver.js
 */
function pnpmResolver(extensions, context, realModuleName, debug, exportsConditionNames = [], mainFields = []) {
    try {
        const pnpmResolve = getPnpmResolver(extensions);
        const lookupStartPath = (0, path_1.dirname)(context.originModulePath);
        const filePath = pnpmResolve.resolveSync({}, lookupStartPath, realModuleName);
        if (filePath) {
            return { type: 'sourceFile', filePath };
        }
    }
    catch {
        if (debug)
            console.log(pc.cyan(`[Nx] Unable to resolve with default PNPM resolver: ${realModuleName}`));
    }
}
/**
 * This function try to resolve files that are specified in tsconfig's paths
 * @returns path if resolved, else undefined
 */
function tsconfigPathsResolver(context, extensions, realModuleName, platform, debug) {
    try {
        const tsConfigPathMatcher = getMatcher(debug);
        const match = tsConfigPathMatcher(realModuleName, undefined, undefined, extensions.map((ext) => `.${ext}`));
        return metroResolver.resolve(context, match, platform);
    }
    catch {
        if (debug) {
            console.log(pc.cyan(`[Nx] Failed to resolve ${pc.bold(realModuleName)}`));
            console.log(pc.cyan(`[Nx] The following tsconfig paths was used:\n:${pc.bold(JSON.stringify(paths, null, 2))}`));
        }
    }
}
let matcher;
let absoluteBaseUrl;
let paths;
function getMatcher(debug) {
    if (!matcher) {
        const result = (0, tsconfig_paths_1.loadConfig)();
        if (result.resultType === 'success') {
            absoluteBaseUrl = result.absoluteBaseUrl;
            paths = result.paths;
            if (debug) {
                console.log(pc.cyan(`[Nx] Located tsconfig at ${pc.bold(absoluteBaseUrl)}`));
                console.log(pc.cyan(`[Nx] Found the following paths:\n:${pc.bold(JSON.stringify(paths, null, 2))}`));
            }
            matcher = (0, tsconfig_paths_1.createMatchPath)(absoluteBaseUrl, paths);
        }
        else {
            console.log(pc.cyan(`[Nx] Failed to locate tsconfig}`));
            throw new Error(`Could not load tsconfig for project`);
        }
    }
    return matcher;
}
/**
 * This function returns resolver for pnpm.
 * It is inspired form https://github.com/vjpr/pnpm-expo-example/blob/main/packages/pnpm-expo-helper/util/make-resolver.js.
 */
let resolver;
function getPnpmResolver(extensions, exportsConditionNames = [], mainFields = []) {
    if (!resolver) {
        const fileSystem = new enhanced_resolve_1.CachedInputFileSystem(fs, 4000);
        resolver = enhanced_resolve_1.ResolverFactory.createResolver({
            fileSystem,
            extensions: extensions.map((extension) => '.' + extension),
            useSyncFileSystemCalls: true,
            modules: [(0, path_1.join)(devkit_1.workspaceRoot, 'node_modules'), 'node_modules'],
            conditionNames: [
                'native',
                'browser',
                'require',
                'default',
                'react-native',
                'node',
                ...exportsConditionNames,
            ],
            mainFields: ['react-native', 'browser', 'main', ...mainFields],
            aliasFields: ['browser'],
        });
    }
    return resolver;
}
