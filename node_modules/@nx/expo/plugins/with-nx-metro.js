"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withNxMetro = withNxMetro;
const devkit_1 = require("@nx/devkit");
const metro_config_1 = require("metro-config");
const node_fs_1 = require("node:fs");
const path_1 = require("path");
const metro_resolver_1 = require("./metro-resolver");
async function withNxMetro(userConfig, opts = {}) {
    const extensions = ['', 'ts', 'tsx', 'js', 'jsx', 'json'];
    if (opts.debug)
        process.env.NX_REACT_NATIVE_DEBUG = 'true';
    if (opts.extensions)
        extensions.push(...opts.extensions);
    let watchFolders = (0, node_fs_1.readdirSync)(devkit_1.workspaceRoot)
        .filter((fileName) => !['dist', 'e2e'].includes(fileName) && !fileName.startsWith('.'))
        .map((fileName) => (0, path_1.join)(devkit_1.workspaceRoot, fileName))
        .filter((filePath) => (0, node_fs_1.statSync)(filePath).isDirectory());
    if (opts.watchFolders?.length) {
        watchFolders = watchFolders.concat(opts.watchFolders);
    }
    watchFolders = [...new Set(watchFolders)].filter((folder) => (0, node_fs_1.existsSync)(folder));
    const nxConfig = {
        resolver: {
            resolveRequest: (0, metro_resolver_1.getResolveRequest)(extensions, opts.exportsConditionNames, opts.mainFields),
            nodeModulesPaths: [(0, path_1.join)(devkit_1.workspaceRoot, 'node_modules')],
        },
        watchFolders,
    };
    return (0, metro_config_1.mergeConfig)(userConfig, nxConfig);
}
