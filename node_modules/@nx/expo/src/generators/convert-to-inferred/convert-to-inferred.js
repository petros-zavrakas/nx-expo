"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToInferred = convertToInferred;
const devkit_1 = require("@nx/devkit");
const aggregate_log_util_1 = require("@nx/devkit/src/generators/plugin-migrations/aggregate-log-util");
const executor_to_plugin_migrator_1 = require("@nx/devkit/src/generators/plugin-migrations/executor-to-plugin-migrator");
const plugin_1 = require("../../../plugins/plugin");
const process_build_options_1 = require("./lib/process-build-options");
const post_target_transformer_1 = require("./lib/post-target-transformer");
const process_export_options_1 = require("./lib/process-export-options");
const process_run_options_1 = require("./lib/process-run-options");
const process_serve_options_1 = require("./lib/process-serve-options");
const process_start_options_1 = require("./lib/process-start-options");
const process_submit_options_1 = require("./lib/process-submit-options");
const process_prebuild_options_1 = require("./lib/process-prebuild-options");
const process_install_options_1 = require("./lib/process-install-options");
async function convertToInferred(tree, options) {
    const projectGraph = await (0, devkit_1.createProjectGraphAsync)();
    const migrationLogs = new aggregate_log_util_1.AggregatedLog();
    const projects = (0, devkit_1.getProjects)(tree);
    const migratedProjects = await (0, executor_to_plugin_migrator_1.migrateProjectExecutorsToPlugin)(tree, projectGraph, '@nx/expo/plugin', plugin_1.createNodesV2, {
        buildTargetName: 'build',
        exportTargetName: 'export',
        installTargetName: 'install',
        prebuildTargetName: 'prebuild',
        runAndroidTargetName: 'run-android',
        runIosTargetName: 'run-ios',
        serveTargetName: 'serve',
        startTargetName: 'start',
        submitTargetName: 'submit',
    }, [
        {
            executors: ['@nx/expo:build'],
            postTargetTransformer: (0, post_target_transformer_1.postTargetTransformer)(migrationLogs, process_build_options_1.processBuildOptions),
            targetPluginOptionMapper: (targetName) => ({
                buildTargetName: targetName,
            }),
        },
        {
            executors: ['@nx/expo:export'],
            postTargetTransformer: (0, post_target_transformer_1.postTargetTransformer)(migrationLogs, process_export_options_1.processExportOptions),
            targetPluginOptionMapper: (targetName) => ({
                exportTargetName: targetName,
            }),
        },
        {
            executors: ['@nx/expo:install'],
            postTargetTransformer: (0, post_target_transformer_1.postTargetTransformer)(migrationLogs, process_install_options_1.processInstallOptions),
            targetPluginOptionMapper: (targetName) => ({
                installTargetName: targetName,
            }),
        },
        {
            executors: ['@nx/expo:prebuild'],
            postTargetTransformer: (0, post_target_transformer_1.postTargetTransformer)(migrationLogs, process_prebuild_options_1.processPrebuildOptions),
            targetPluginOptionMapper: (targetName) => ({
                prebuildTargetName: targetName,
            }),
        },
        {
            executors: ['@nx/expo:run'],
            postTargetTransformer: (0, post_target_transformer_1.postTargetTransformer)(migrationLogs, process_run_options_1.processRunOptions),
            targetPluginOptionMapper: (targetName) => {
                // Assumption: There are no targets with the same name but different platforms.
                // Most users will likely keep the `run-ios` and `run-android` target names that are generated.
                // Otherwise, we look for the first target with a matching name, and use that platform.
                const platform = getPlatformForFirstMatchedTarget(targetName, '@nx/expo:run', projects);
                return {
                    [platform === 'android'
                        ? 'runAndroidTargetName'
                        : 'runIosTargetName']: targetName,
                };
            },
        },
        {
            executors: ['@nx/expo:serve'],
            postTargetTransformer: (0, post_target_transformer_1.postTargetTransformer)(migrationLogs, process_serve_options_1.processServeOptions),
            targetPluginOptionMapper: (targetName) => ({
                serveTargetName: targetName,
            }),
        },
        {
            executors: ['@nx/expo:start'],
            postTargetTransformer: (0, post_target_transformer_1.postTargetTransformer)(migrationLogs, process_start_options_1.processStartOptions),
            targetPluginOptionMapper: (targetName) => ({
                startTargetName: targetName,
            }),
        },
        {
            executors: ['@nx/expo:submit'],
            postTargetTransformer: (0, post_target_transformer_1.postTargetTransformer)(migrationLogs, process_submit_options_1.processSubmitOptions),
            targetPluginOptionMapper: (targetName) => ({
                submitTargetName: targetName,
            }),
        },
    ], options.project);
    if (migratedProjects.size === 0) {
        throw new executor_to_plugin_migrator_1.NoTargetsToMigrateError();
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(tree);
    }
    return () => {
        migrationLogs.flushLogs();
    };
}
function getPlatformForFirstMatchedTarget(targetName, executorName, projects) {
    for (const [, project] of projects) {
        const target = project.targets[targetName];
        if (target && target.executor === executorName && target.options.platform) {
            return target.options.platform;
        }
    }
    // Default is ios in executor, although we do always generate it in project.json.
    return 'ios';
}
exports.default = convertToInferred;
