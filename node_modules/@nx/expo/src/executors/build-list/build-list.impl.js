"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = buildListExecutor;
exports.runCliBuildList = runCliBuildList;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const child_process_1 = require("child_process");
const resolve_eas_1 = require("../../utils/resolve-eas");
let childProcess;
async function* buildListExecutor(options, context) {
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    try {
        if (options.json) {
            // when json is true, interactive has to be false
            options.interactive = false;
        }
        await runCliBuildList(context.root, projectRoot, options);
        yield { success: true };
    }
    finally {
        if (childProcess) {
            childProcess.kill();
        }
    }
}
function runCliBuildList(workspaceRoot, projectRoot, options) {
    return new Promise((resolve, reject) => {
        childProcess = (0, child_process_1.fork)((0, resolve_eas_1.resolveEas)(workspaceRoot), ['build:list', ...createBuildListOptions(options)], {
            cwd: (0, path_1.resolve)(workspaceRoot, projectRoot),
            env: process.env,
            stdio: ['inherit', 'pipe', 'inherit', 'ipc'], // only stream stdout on child process
        });
        // Ensure the child process is killed when the parent exits
        process.on('exit', () => childProcess.kill());
        process.on('SIGTERM', () => childProcess.kill());
        let output = '';
        childProcess.stdout.on('data', (message) => {
            output += message.toString();
            devkit_1.logger.info(message.toString());
            // when interactive is false, resolve the promise when the child process exits
            if (options.interactive === false) {
                resolve(message.toString());
            }
        });
        childProcess.on('error', (err) => {
            reject(err);
        });
        childProcess.on('exit', (code) => {
            if (code === 0) {
                resolve(output);
            }
            else {
                reject(code);
            }
        });
    });
}
const nxOptions = ['output'];
function createBuildListOptions(options) {
    return Object.keys(options).reduce((acc, optionKey) => {
        const optionValue = options[optionKey];
        if (!nxOptions.includes(optionKey)) {
            if (optionKey === 'interactive') {
                if (optionValue === false) {
                    acc.push(`--non-interactive`);
                }
            }
            else if (typeof optionValue === 'boolean') {
                if (optionValue === true) {
                    // when true, does not need to pass the value true, just need to pass the flag in camel case
                    acc.push(`--${(0, devkit_1.names)(optionKey).propertyName}`);
                }
            }
            else {
                acc.push(`--${(0, devkit_1.names)(optionKey).propertyName}`, optionValue);
            }
        }
        return acc;
    }, []);
}
