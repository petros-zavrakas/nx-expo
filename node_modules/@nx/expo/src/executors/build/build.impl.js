"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = buildExecutor;
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const child_process_1 = require("child_process");
const node_fs_1 = require("node:fs");
const path_1 = require("path");
const resolve_eas_1 = require("../../utils/resolve-eas");
let childProcess;
async function* buildExecutor(options, context) {
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    let resetLocalFunction;
    try {
        resetLocalFunction = copyPackageJsonAndLock((0, devkit_1.detectPackageManager)(context.root), context.root, projectRoot);
        await runCliBuild(context.root, projectRoot, options);
        yield { success: true };
    }
    finally {
        resetLocalFunction();
        if (childProcess) {
            childProcess.kill();
        }
    }
}
function runCliBuild(workspaceRoot, projectRoot, options) {
    return new Promise((resolve, reject) => {
        childProcess = (0, child_process_1.fork)((0, resolve_eas_1.resolveEas)(workspaceRoot), ['build', ...createBuildOptions(options)], {
            cwd: (0, path_1.resolve)(workspaceRoot, projectRoot),
            env: {
                ...(options.local ? { YARN_ENABLE_IMMUTABLE_INSTALLS: 'false' } : {}),
                ...process.env,
            },
        });
        // Ensure the child process is killed when the parent exits
        process.on('exit', () => childProcess.kill());
        process.on('SIGTERM', () => childProcess.kill());
        childProcess.on('error', (err) => {
            reject(err);
        });
        childProcess.on('exit', (code) => {
            if (code === 0) {
                resolve(code);
            }
            else {
                reject(code);
            }
        });
    });
}
function createBuildOptions(options) {
    return Object.keys(options).reduce((acc, k) => {
        const v = options[k];
        if (typeof v === 'boolean') {
            if (k === 'interactive') {
                if (v === false) {
                    acc.push('--non-interactive'); // when is false, the flag is --non-interactive
                }
            }
            else if (k === 'wait') {
                if (v === false) {
                    acc.push('--no-wait'); // when is false, the flag is --no-wait
                }
                else {
                    acc.push('--wait');
                }
            }
            else if (v === true) {
                // when true, does not need to pass the value true, just need to pass the flag in kebob case
                acc.push(`--${(0, devkit_1.names)(k).fileName}`);
            }
        }
        else {
            acc.push(`--${(0, devkit_1.names)(k).fileName}`, v);
        }
        return acc;
    }, []);
}
/**
 * This function:
 * - copies the root package.json and lock file to the project directory
 * - returns a function that resets the project package.json and removes the lock file
 */
function copyPackageJsonAndLock(packageManager, workspaceRoot, projectRoot) {
    const packageJson = (0, path_1.resolve)(workspaceRoot, 'package.json');
    const rootPackageJson = (0, devkit_1.readJsonFile)(packageJson);
    // do not copy package.json and lock file if workspaces are enabled
    if ((packageManager === 'pnpm' &&
        (0, node_fs_1.existsSync)((0, path_1.resolve)(workspaceRoot, 'pnpm-workspace.yaml'))) ||
        rootPackageJson.workspaces) {
        // no resource taken, no resource cleaned up
        return () => { };
    }
    const packageJsonProject = (0, path_1.resolve)(projectRoot, 'package.json');
    const projectPackageJson = (0, devkit_1.readJsonFile)(packageJsonProject);
    const lockFile = (0, js_1.getLockFileName)((0, devkit_1.detectPackageManager)(workspaceRoot));
    const lockFileProject = (0, path_1.resolve)(projectRoot, lockFile);
    const rootPackageJsonDependencies = rootPackageJson.dependencies;
    const projectPackageJsonDependencies = { ...projectPackageJson.dependencies };
    const rootPackageJsonDevDependencies = rootPackageJson.devDependencies;
    const projectPackageJsonDevDependencies = {
        ...projectPackageJson.devDependencies,
    };
    projectPackageJson.dependencies = rootPackageJsonDependencies;
    projectPackageJson.devDependencies = rootPackageJsonDevDependencies;
    const projectOverrides = projectPackageJson.overrides;
    const projectResolutions = projectPackageJson.resolutions;
    if (rootPackageJson.overrides) {
        projectPackageJson.overrides = rootPackageJson.overrides;
    }
    // if overrides exists, give precedence to it over resolutions
    if (!rootPackageJson.overrides && rootPackageJson.resolutions) {
        projectPackageJson.resolutions = rootPackageJson.resolutions;
    }
    // Copy dependencies from root package.json to project package.json
    (0, devkit_1.writeJsonFile)(packageJsonProject, projectPackageJson);
    // Copy lock file from root to project
    (0, node_fs_1.copyFileSync)(lockFile, lockFileProject);
    return () => {
        // Reset project package.json to original state
        projectPackageJson.dependencies = projectPackageJsonDependencies;
        projectPackageJson.devDependencies = projectPackageJsonDevDependencies;
        if (projectOverrides) {
            projectPackageJson.overrides = projectOverrides;
        }
        else {
            delete projectPackageJson.overrides;
        }
        if (projectResolutions) {
            projectPackageJson.resolutions = projectResolutions;
        }
        else {
            delete projectPackageJson.resolutions;
        }
        (0, node_fs_1.writeFileSync)(packageJsonProject, JSON.stringify(projectPackageJson, null, 2));
        // Remove lock file from project
        (0, node_fs_1.rmSync)(lockFileProject, { recursive: true, force: true });
    };
}
