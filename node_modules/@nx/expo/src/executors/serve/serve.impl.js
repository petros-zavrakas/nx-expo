"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = serveExecutor;
exports.runCliServe = runCliServe;
const devkit_1 = require("@nx/devkit");
const child_process_1 = require("child_process");
const path_1 = require("path");
const is_packager_running_1 = require("./lib/is-packager-running");
async function* serveExecutor(options, context) {
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    const serveProcess = await runCliServe(context.root, projectRoot, options);
    yield {
        port: options.port,
        baseUrl: `http://localhost:${options.port}`,
        success: true,
    };
    if (!serveProcess) {
        return;
    }
    await new Promise((resolve) => {
        const processExitListener = (signal) => () => {
            serveProcess.kill(signal);
            resolve();
            process.exit();
        };
        process.once('exit', (signal) => serveProcess.kill(signal));
        process.once('SIGTERM', processExitListener);
        process.once('SIGINT', processExitListener);
        process.once('SIGQUIT', processExitListener);
    });
}
async function runCliServe(workspaceRoot, projectRoot, options) {
    const result = await (0, is_packager_running_1.isPackagerRunning)(options.port);
    if (result === 'running') {
        devkit_1.logger.info(`JS server already running on port ${options.port}.`);
    }
    else if (result === 'unrecognized') {
        devkit_1.logger.warn('JS server not recognized.');
    }
    else {
        // result === 'not_running'
        devkit_1.logger.info('Starting JS server...');
        try {
            return await serveAsync(workspaceRoot, projectRoot, options);
        }
        catch (error) {
            devkit_1.logger.error(`Failed to serve the packager server. Error details: ${error.message}`);
            throw error;
        }
    }
}
function serveAsync(workspaceRoot, projectRoot, options) {
    return new Promise((resolve, reject) => {
        const childProcess = (0, child_process_1.fork)(require.resolve('@expo/cli/build/bin/cli'), ['start', '--web', ...createServeOptions(options)], {
            cwd: (0, path_1.resolve)(workspaceRoot, projectRoot),
            env: process.env,
            stdio: ['inherit', 'pipe', 'pipe', 'ipc'],
        });
        childProcess.stdout.on('data', (data) => {
            process.stdout.write(data);
            if (data.toString().includes('Bundling complete') ||
                data.toString().includes('Bundled')) {
                resolve(childProcess);
            }
        });
        childProcess.stderr.on('data', (data) => {
            process.stderr.write(data);
        });
        childProcess.on('error', (err) => {
            reject(err);
        });
        childProcess.on('exit', (code) => {
            if (code === 0) {
                resolve(childProcess);
            }
            else {
                reject(code);
            }
        });
    });
}
function createServeOptions(options) {
    return Object.keys(options).reduce((acc, k) => {
        const v = options[k];
        if (k === 'dev') {
            if (v === false) {
                acc.push(`--no-dev`); // only no-dev flag is supported
            }
        }
        else {
            if (typeof v === 'boolean') {
                if (v === true) {
                    // when true, does not need to pass the value true, just need to pass the flag in kebob case
                    acc.push(`--${(0, devkit_1.names)(k).fileName}`);
                }
            }
            else {
                acc.push(`--${(0, devkit_1.names)(k).fileName}`, v);
            }
        }
        return acc;
    }, []);
}
